# 实验原理

&emsp;&emsp;防火墙是广泛部署在网络中的一项重要的安全技术，它用来限制网络中一端到另一端的通信。

## 1 防火墙概述

### 1.1 防火墙策略

&emsp;&emsp;防火墙能否有效地保护网络取决于防火墙的规则设置。防火墙策略定义了不同类型的规则。

&emsp;&emsp;（1）用户控制：基于用户角色来控制访问，通常应用于防火墙内的用户；

&emsp;&emsp;（2）服务控制：基于服务类型来控制访问。这种控制的实现主要基于网络地址、端口号和连接协议。

&emsp;&emsp;（3）方向控制：基于方向来控制访问，即数据是从外部流入防火墙内部（inbound）还是从防火墙内部流向外部（outbound）。

### 1.2 防火墙的动作

&emsp;&emsp;防火墙对于流经的数据包可采取三种动作。

&emsp;&emsp;（1）accepted：允许数据包通过防火墙进入连接的网络或者主机

&emsp;&emsp;（2）denied： 不允许数据包通过防火墙。

&emsp;&emsp;（3）rejected: 这个动作和denied类似，但防火墙会用ICMP包告知数据源数据包被拒绝的原因。

### 1.3 双向过滤

&emsp;&emsp;防火墙可以进行双向网络流量检查。

&emsp;&emsp;当防火墙的目的是保护内部网络以防止外部网络潜在的攻击时，它检查进入内网的流量，这称为入口过滤（ingress filter）；

&emsp;&emsp;当防火墙的目的是避免内网用户访问某个外网地址或者发送某种类型的数据时，它检查流向外网的流量，这称为出口过滤（egress filtering）。

## 2 防火墙种类

&emsp;&emsp;基于操作模式，防火墙可分为三类：数据包过滤器、状态防火墙和应用防火墙，如下图所示：

<center><img src="../assets/2-1.png" width = 500></center>

### 2.1 数据包过滤器

&emsp;&emsp;数据包过滤器通过数据包的头部信息来判断是接受还是拒绝数据包，它并不查看数据包载荷中的应用数据。

&emsp;&emsp;它检查流经它的每个数据包，根据数据包本身所带的信息决定它的去留，而不用参考其他数据包的内容。例如，它不会查看数据包是否属于一个已存在的流量。数据包过滤器最大的优点是高效，因为它无须维持数据包的状态。因此，这种防火墙也称作无状态防火墙。

### 2.2 状态防火墙

&emsp;&emsp;状态防火墙会通过对流经的数据包的分析查找通信中的数据流，根据数据流的信息来帮助判断是否让数据包通行。数据流提供了数据包的上下文。

&emsp;&emsp;状态防火墙相比包过滤器有不少优势。例如，如果防火墙的服务器提供了很多对外的服务端口，数据包过滤器必修允许很大范围端口号的流量通过，否则服务器将难以正常运转。而状态防火墙可以缩小这个范围，它可以只允许一个已有数据流内的数据包通过，而拒绝其他不属于已有数据里䣌数据包，除非它们是用来创建新数据流的。提高了防火墙的安全性。

### 2.3 应用防火墙

&emsp;&emsp;应用防火墙对一个特定的应用或服务采取控制，除了控制访问外，还可以检查这个特定应用的输入输出。与上面两种防火墙不同，应用防火墙可以检查应用层的数据，而前两种防火墙通常只能检查传输层及其下层的通信。

&emsp;&emsp;应用防火墙的一种典型实现方式是通过代理，因此也称为应用代理防火墙。应用防火墙在网络中扮演类似中间人的角色。客户机到服务器的请求会交给代理，由代理发起到目的服务器的连接。应用防火墙分析数据包中各层的数据，决定数据包应被接受还是丢弃。

&emsp;&emsp;由于应用防火墙能对应用数据进行检查，因此它可以提供更高的安全性。但是它也有一定的局限性，因为处理不同的网络协议需要建立不同的代理。

&emsp;&emsp;应用防火墙的优点之一是能够直接基于用户身份进行验证，而不光依靠设备的网络地址，减少了IP伪造攻击的风险。由于要分析整个数据包，应用防火墙的处理速度明显慢于其他类型的防火墙，因此不使用于实时或高宽带的应用。

## 3 内核模块

&emsp;&emsp;数据包过滤器只能在内核中实现，因此代码需要运行在内核中。Linux提供了两项重要技术，使得无需重新编译整个内核就能实现数据包过滤器。分别是可加载内核模块（loadable kernel modules）和 Netfilter。

&emsp;&emsp;Linux内核时模块化设计的，因此只有很小一部分被加载进内核。如果需要扩展内核的功能，可以将这些功能设计成内核模块，动态地载入内核。内核模块可以根据实时需求载入或者卸载内核模块。

&emsp;&emsp;每个内核模块都有两个入口点，一个用于载入模块，一个用于卸载模块。宏module_init()和module_exit()是用来指定这两个入口点的函数。module_init()指定的函数在模块载入时被调用，用来进行初始化。module_eixt()指定的函数在模块卸载时被调用，用来进行清理工作。

&emsp;&emsp;Netfilter在数据包经过的路径上放置了一些钩子（hook），它们位于内核中。自行编写的函数可以通过内核模块放进内核，并挂在那些钩子上。当数据包到达某个钩子时，挂在钩子上面的函数就会被调用，可以在函数中对数据包进行审查和过滤，并告诉Netfilter如何处理。

## 4 Netfilter

&emsp;&emsp;Linux内核通过Netfilter的钩子函数提供了强大的数据包处理及过滤框架。在Linux中，每个协议栈都在数据包经过的路径上定义了一些了钩子点。开发者使用内核模块间他们定义的函数“钩”到这些钩子点上，当数据包到达每个钩子点时，协议栈会调用Netfilter框架，查找是否有内核模块挂在这些钩子点，如果有，这些模块注册的函数会被调用，这时他们得以分析或处理数据包。最后，他们将返回对数据包的处理结果。

## 4.1 钩子点对数据包的处理结果
   
   有5种，说明如下：

    （1）NF_ACCEPT:允许数据包通过。
    （2）NF_DROP:丢弃数据包，这样数据包将不会在网络协议种继续传输。
    （3）NF_QUEUE:使用nf_queue机制将数据包传递到用户空间处理。
    （4）NF_STOLEN:告知Netfilter框架忽略这个数据包。
       这个操作主要是把数据包进一步的处理工作从Netfilter转交给模块。
       数据包在内核内表中仍然是有效的。典型用途是把分片的数据包存储起来，以便在同一个上下文中分析它们。
    （5）NF_REPEAT:请求Netfilter框架再次调用这个模块。

## 4.2 IPv4中的Netfilter钩子函数

&emsp;&emsp;Netfliter为IPv4定义了5种钩子函数。

    （1）NF_INET_PRE_ROUTING:除了混杂模式，所有数据包都将经过这个钩子点。它上面注册的钩子函数在路由判决前被调用。
    （2）NF_INET_LOCAL_IN:数据包要进行路由判决，以决定需要被转发还是发往本机。
        前一种情况下，数据包将签完转发路径；
        后一种情况下，数据包将通过这个钩子点，之后被发送到网络协议栈，并最终被主机接收。
    （3）NF_INET_FORWARD:需要被转发的数据包会到达这个钩子点。这个钩子点对于实现一个防火墙是十分重要的。
    （4）NF_INET_LOCAL_OUT:这是本机产生的数据包到达的第一个钩子点。
    （5）NF_INET_POST_ROUTING:需要被转发或者由本机产生的数据包都会经过这个钩子点。
        源网络地址转换（source network translation, SNAT）就是用这个钩子点实现的。

## 5 iptables 防火墙

&emsp;&emsp;Linux自带有一个功能很强大的防火墙iptables，也是基于Netfilter。严格来说，该防火墙在内核中的部分叫作xtables，而iptables是用户空间用来设置防火墙的程序。但是一般我们就把iptables作为内核部分和用户空间部分两者的统称。

### 5.1 iptables 防火墙的结构

&emsp;&emsp;iptables 防火墙不仅可以用来过滤数据包，还可以修改数据包。为了方便管理，iptables使用表和链来管理不同的防火墙规则。每个表存放不同用途的规则，每个表有若干个链，每个链对应一个Netfilter的钩子。每个链保存待执行的防火墙规则，默认情况下，它们是空的，由用户添加规则到链中。下图列出了iptables最常用的三个表和它们的链。

<center><img src="../assets/2-2.png" width = 500></center>