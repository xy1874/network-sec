# 实验原理

在CPU指令流水线设计中，为了提高计算机系统的执行效率，从而加入了Cache、TLB等缓存结构让多个不同的进程之间共享，因此在一定程度上打破了计算机系统中基于内存隔离实现的安全边界；同时CPU采用的乱序执行、分支预测和推测执行等性能优化也存在着严重的安全缺陷。2018年初爆出的安全漏洞Meltdown和Spectre就是利用CPU的这些安全缺陷。
Meltdown攻击的原理是透过乱序执行来随机读取内核空间的信息，可能包括个人的数据和密码。利用侧信道攻击打破了内核空间的地址不能被用户空间代码直接访问的内存隔离原则。

## 1. 内存隔离

内存隔离是现代计算机体系结构的一个核心概念，是操作系统的安全特征之一。操作系统保证用户程序彼此之间无法访问对方的内存，并且阻止用户系统对内核内存进行读写操作。这样的隔离机制能够使得一个设备上允许并行多个应用程序。
我们在操作系统实验的页表这个实验中，了解过用户地址空间和内核地址空间的概念，这种设计方式可以防止用户程序访问别的用户地址空间或者内核地址空间。内核和用户进程之间的隔离通常由一个标记位实现，该标记位定义了内存页面是否可以访问，这个标志位只能被内核控制，其基本思想是只有当进入内核代码时才能设置该位，而切换到用户进程时该位被清除。这样的硬件特性允许操作系统将内核映射到每个进程的地址空间，硬件可以通过这种方式可以高效的实现多任务的切换，比如中断处理函数，当从用户态切换到内核态时，地址映射是没有变化的。




## 2. 乱序执行

随着处理器(CPU)技术的发展，处理器执行指令的速度越来越快，与内存读写速度的差距越来越大，乱序执行就是为了解决这种时间差异而产生的技术，它是为提高系统的性能而做的重要优化。

早期的处理器依次顺序执行既定的处理器指令，而现代处理器为了提高性能并不严格按照指令的顺序串行执行，而是对执行进行相关性分析后并行处理乱序执行。比如当处理器中的某些指令需要等待某些资源，处理器不会真的在这里等待而停止指令的执行，而是利用等待资源的时间继续执行后续的指令。在支持乱序执行的CPU中，后面的指令可能在前面指令执行结束前就开始执行了。

为了保证程序运行的正确性，处理器会对指令执行安全检查，只有当前用户权限符合指令权限时才能被执行，比如用户空间的指令访问内核内存处理器就会抛出异常。然而安全检查这个操作只有在指令执行的结果真正被提交并对系统可见时才会发生时才会进行。也就是说，如果在乱序执行中，指令并没有真正执行完成而只是加载到缓存中是不会执行安全检查的。而此时由于乱序执行而被提前执行的指令会被处理器丢弃，但由于乱序执行的指令对缓存的操作在这些指令被丢弃时不会被重置。正是安全检查与乱序执行的空窗期才会让Meltdown有机可乘。

预测执行涉及到程序的控制流，现在处理器不是去解析所有分支指令后然后决定执行哪个操作，而是预测哪个控制流会更有可能被运行再提取相应的指令代码执行。如果预测正确的话，会带来很高的性能提升并提高处理器的并行性。如果预测错误，那些被预测执行的不正确结果会被丢弃，处理器会将状态恢复到预测执行行前的正确状态，再重新跳转到正确执行的分支或指令中运行。与乱序执行类似，预测执行对处理器缓存的操作会被保留。



## 3. Cache

**Cache** 是为了解决 CPU 与慢速内存设备之间巨大的速度差异而出现的。每次 CPU 需要访问内存时，首先查找 Cache，如果 Cache 中存在对应的数据，那么命中，称为 hit ，否则未命中，则再向内存要数据，称为 miss。
Cache 一般设置为3级，每个内核都有一个独享的L1Cache（L1Cache分为数据缓存和指令缓存）和L2Cache，而L3Cache是所有的内核共享缓存。
Cache的单位是Cacheline，是一块连续的内存，在一般的x86环境下一个CacheLine是64字节。

<center><img src="../assets/1-1 三级Cache位置.png" width = 600></center>

## 4. Cache侧信道攻击

多核之间Cache数据共享，而Cache命中和失效对应响应时间有差别，攻击者可以通过访问时间的差异，推测Cache中的信息，从而获得隐私数据。

**Flush-Reload**方法是Cache侧信道攻击中访问驱动攻击的其中一种比较流行的方法，基于共享内存实现，是一种跨内核、跨虚拟机的Cache 探测方法。在Flush 阶段，攻击者将监控的内存块从Cache中驱逐出去，然后在Trigger阶段等待目标用户访问共享内存。在Reload阶段，攻击者重新加载监控的共享内存块。如果在等待的期间，目标虚拟机访问过的内存块需要重新加载，时间将会较短，因为这些数据已经被缓存在Cache中。根据加载时间长短，可判定目标虚拟机访问过的数据。


## 5. 异常处理

为了保证程序执行的正确性，异常指令后面的指令不会提交，但是由于乱序执行的机制，后面的一些访问内存的指令可能已经把物理内存数据预取到Cache中了，这就给Meltdown漏洞留下来进行攻击获取，虽然这些数据最终也会被丢弃掉。

与C++或其他高级语言不同，C不提供对异常处理的直接支持，例如try/catch子句。但是，我们可以模拟try/catch子句，使用sigsetjmp（）和siglongjmp（）来实现。
模拟try/catch子句的异常处理机制需要注意如下四点内容：
1. 设置信号处理程序：我们在代码注册一个SIGSEGV信号处理程序，因此，当引发SIGSEGV信号时，将调用处理程序函数catch segv（）。
2. 设置检查点：在信号处理程序完成异常处理之后，需要让程序从特定的检查点继续执行。因此，我们需要首先定义一个检查点，把将堆栈上下文/环境保存起来。
3. 回滚到检查点：在异常处理之后，程序将从else分支继续执行。
4. 触发异常：由于内存访问冲突（用户级程序无法访问内核内存），相关代码将触发SIGSEGV信号。


