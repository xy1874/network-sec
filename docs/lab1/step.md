# 实验步骤

Meltdown这种攻击方式允许任何用户进程读取执行机器上的整个内核内存，包括映射到内核区域的所有物理内存，从而完全攻克 **内存隔离** 。

本次实验分几个步骤来完成Meltdown的攻击。

Task1&2 完成一个简单的侧信道攻击的示例；

Task3-5 为Meltdown攻击做准备；

Take6 为乱序执行的示例；

Task7 完成一次基础的Meltdown攻击；

Task8 给出一个更加实用的攻击效果。

!!! info "提示 :sparkles:"
    所有的任务在编译时加上 -march=native 的标志，它会告诉编译器启用本地计算机支持的所有指令子集。所有本次实验需要的代码都在下载的资料Labsetup.zip中，也已上传到QQ群。

## **侧信道攻击CPU缓存**

任务1和任务2目的是用侧信道攻击从CPU缓存中读取到被保护的数据。

### 1. 分别测试从 Cache 读取和从内存读取数据的时间长度，对比时间差。

这个任务的实现主要是利用从 Cache 中读取数据的速度比从 RAM 中读取数据的速度快的特点。

在代码（CacheTime.c）中，有一个大小为 [10*4096] 的数组。首先访问它的两个元素，[3*4096] 和 [7*4096], 程序会将包含这两个元素的信息进行缓存。然后再从数组中访问[0*4096]....[9*4096]这10个元素，并输出访问的时间。如下图所示。

从下图可以看出[3*4096] 和 [7*4096] 的时间花费明显小于其他元素的时间，这是因为在遍历之前我们已经访问过着两个元素，他们已经被加载到Cache当中了。

 <center><img src="../assets/1-2 访问时间对比.png" width = 600></center>

本次任务不需要编码，只需要在CacheTime所在的文件夹下运行如下命令即可。

    $gcc -march=native CacheTime.c -o CacheTime
    $ ./CacheTime

!!! info "提示 :sparkles:"
    其中，这个march标志告诉编译器启用本地计算机支持的所有指令子集。


请运行./ CacheTime 10次或以上，从运行结果中，找到用于区分缓存和RAM这两种内存访问类型的阈值，这个阈值将用于后续的task中。


!!! info "说明 :sparkles:"
    Cache的单位是CacheLine，是一块连续的内存，在一般的x86环境下一个CacheLine是64字节。在把某个数据加载到Cache中时，不是只加载这个数据，而是加载整个CacheLine大小的内存块。因此我们在上面设置访问数据的时候，先访问了[3*4096] 和 [7*4096]，另外在遍历时也是每隔4096大小进行访问，首先确保这些数组元素不在同一个CacheLine大小的内存块，。

**任务1需提交内容**最后一次的运行结果截图，并将你选择的阈值进行说明，截图可参考下图。

 <center><img src="../assets/2-1 task1截图.png" width = 600></center>


### 2. 完成利用缓存进行侧信道攻击的示例

本次任务的目标是通过侧通道攻击来提取受害者函数使用的秘密值。 

假设有一个受害者函数使用一个秘密值（假设是94）作为索引从数组中加载一些值。而这个秘密值不能从外部访问。我们的目标是利用缓存侧信道攻击来访问这个秘密值。

使用的技术为 FLUSH+RELOAD , 攻击者首先刷新指令清空高速缓存的数据，然后等待被攻击者去读取数据，因为数据不在高速缓存中，所以被攻击者请求的任务数据都必须从主存储器中获取，读入到缓存中。

然后，攻击者遍历相关的数据，同时测定这一过程所需要的时间。时间少的就是缓存中命中的数据，也就是被攻击这访问过的数据。如下图所示。

<center><img src="../assets/2-2 task2侧信道攻击原理图.png" width = 600></center>

这一过程包含三个步骤：

1. 在缓存中刷新整个数组，以确保该数组未被缓存。
2. 调用受害者函数，该函数根据秘密值访问其中一个数组元素。此操作将缓存相应的数组元素。
3. 重新加载整个数组，并输出重新加载每个元素所需的时间。如果有一个元素的加载时间很快，很可能元素已经在缓存中。这个元素一定是受害者函数访问过的秘密值。因此，我们可以推测出秘密值是什么。
	
需要注意的是，缓存是在块级别（CacheLine）完成的，而不是在字节级别。为了避免受到块的边界值的影响，我们对所有k值使用 array[k*4096+DELTA] ，其中DELTA定义为常量1024。

在实验过程中，程序（FlushReload.c）中的秘密值可以做适当的修改验证，可以将94改为你学号的后2位，把原有的阈值80改成了从task 1中获得的阈值。

<center><img src="../assets/3-1.png" width = 400></center>

运行指令如下：

    $ gcc -march=native FlushReload.c -o FlushReload
    $ ./FlushReload

运行./ FlushReload 20次，查看成功的次数（并不是100%成功的），看是否能够获取到准确的秘密值。测试完成后，尝试测试下将阈值修改为一个比较大或比较小的值，观察看运行结果是否能够获取到准确的秘密值。

**任务2需提交内容** 根据选取的合适阈值，截取运行多次（至少6次）的结果截图；将阈值任意调大调小后测试查看是否能够获取到秘密值，并说明原因。

<center><img src="../assets/2-3 task2结果截图.png" width = 600></center>

## **从内核空间读取秘密值**

接下来的任务3到任务5都是为开展Meltdown攻击做准备，任务3将一个秘密值加载到内核空间，任务4从用户态读取内核的数据，任务5完成C语言的异常处理。

### 3 将秘密数据加载到内核空间

为了简化攻击，我们在内核空间中存储了一个秘密值（/proc/secret_data），本次任务我们需要将秘密值加载到内核模块，并获得秘密值的地址信息。

首先需要编译和安装内核模块。键入 make 命令编译内核模块, 使用 insmod 命令安装这个内核模块。一旦我们成功地安装了内核模块，我们可以使用 dmesg 命令从内核消息缓冲区中查找秘密值的地址。该地址在后续的任务中使用，请保存下来。

在 MeltdownKernel.c 文件所在目录下，运行指令如下（本次用到的两个文件分别是make和MeltdownKernel.c）：

    $ make
    $ sudo insmod MeltdownKernel.ko   
    $ dmesg | grep ‘secret data address’  

通过上面的三个命令，找到秘密数据的地址，用于后面的task。

!!! info "说明 :sparkles:"
    Linux insmod（英文全拼：install module）命令用于载入模块。Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。
    显示开机信息
    Linux dmesg 命令可以显示系统开机启动信息。内核会将开机启动信息存储在 ring buffer（环形缓冲区）中。您若是开机时来不及查看信息，可利用dmesg命令来查看。开机信息保存在 /var/log/dmesg 日志文件里。某些硬件设备在安装时，通常会安装驱动程序（内核模块），会打印一些信息，也可以通过dmesg命令来查看。


**任务3需提交内容** 截图获取到秘密数据的地址。

### 4 从用户空间访问内核内存

本次任务我们需要从用户级程序获取上个任务加载到内核中的秘密数据。通过上一个任务获得了秘密数据的地址，我们尝试从用户空间获得内核空间的信息（比如上个任务中的秘密数据）。

你可以为这个实验编写自己的代码。我们提供了一个代码样本如下。行中的地址➀, 您应该将其替换为从上一个任务得到的值。

<center><img src="../assets/2-4 task4代码截图.png" width = 600></center>

运行指令如下：

    $ gcc -march=native UsertoKernel.c -o UsertoKernel
    $ ./UsertoKernel

通过用户空间直接访问内核内存，观察执行结果。你会发现有段地址错误的信息，说明不能直接通过用户空间直接访问内核的内存地址空间。


**任务4需提交内容** 编译并运行这个程序（或你自己的代码），并描述你的观察结果。在line➁程序能成功执行么? 程序能执行到line➁么?

### 5. 处理程序的错误/异常

通过任务4我们知道从用户空间访问内核内存将导致程序崩溃。如何不让程序直接崩溃呢？那就需要添加处理异常的程序。本次任务就是在程序中定义自己的信号处理程序来捕获异常。

与C++或其他高级语言不同，C不提供对异常处理的直接支持，例如 try/catch 子句。但是，我们可以模拟 try/catch 子句，使用 sigsetjmp（）和 siglongjmp（）来实现。

模拟 try/catch 子句的异常处理机制需要注意如下四点内容：

1. 设置信号处理程序：我们在代码注册一个 SIGSEGV 信号处理程序，因此，当引发 SIGSEGV 信号时，将调用处理程序函数 catch segv（）。
2. 设置检查点：在信号处理程序完成异常处理之后，需要让程序从特定的检查点继续执行。因此，我们需要首先定义一个检查点，将堆栈上下文/环境保存起来。
3. 回滚到检查点：在异常处理之后，程序将从 else 分支继续执行。
4. 触发异常：由于内存访问冲突（用户级程序无法访问内核内存），相关代码将触发 SIGSEGV 信号。

运行指令如下：
    
    $ gcc -march=native  ExceptionHandling.c -o  ExceptionHandling
	$ ./ExceptionHandling
    

**任务5需提交内容** 观察执行结果，看看程序是否顺利完成了对 SIGSEGV 信号的处理并往下执行。

## **CPU乱序执行引起的Meltdown攻击**

任务6到任务8利用CPU乱序执行的特性开展的Meltdwon攻击，能够在用户空间获取到内核空间的秘密数据。

### 6. CPU的乱序执行

从任务4中，我们知道如果一个用户程序试图读取内核内存，访问将失败并且将引发异常。

那么观察下面的代码，我们知道第3行将引发一个异常，因为秘密数据的内存地址属于内核。因此，执行将在第 3 行中断，而第 4 行永远不会执行，因此number变量的值将还是0。

<center><img src="../assets/2-6 task6 代码截图.png" width = 600></center>

在上面的代码示例中，在微体系结构级别，第3行涉及两个操作：加载数据（通常到寄存器中），以及检查是否允许数据访问。

如果数据已经在CPU缓存中，则第一个操作将非常快，而第二个操作可能需要一段时间。为避免等待，CPU将继续执行第4行和后续指令，同时并行执行访问检查。这是乱序执行, 访问检查完成之前，不会提交执行结果。

在我们的例子中，检查失败，因此所有乱序执行导致的结果都将被丢弃，就像从未发生过一样。这就是为什么从外面我们看不到第4行被执行的原因。

如果我们进入CPU，并查看微体系结构的执行序列，将发现第3行将成功获取内核数据，而第4行和后续指令将被执行。这是由于现代CPU是乱序执行的。

<center><img src="../assets/2-7 task6 CPU乱序执行截图.png" width = 600></center>

MeltdownExperiment.c 的代码如下， line➀ 将会引起异常，所以 line➁ 将不会被执行。但是因为CPU的乱序执行，line➁ 可能已经被 CPU 执行了，但是结果会被忽略，用户看不到结果。虽然如此， CPU 已经把 array[7*4096 + DELTA] 的值加载到了 Cache 中。那么利用 **任务1** 和 **任务2** 的侧信道攻击方式，就能够观察我们所需要的信息。



<center><img src="../assets/2-8 task6 MeltdownExperiment的截图.png" width = 600></center>

修改 MeltdownExperiment.c 文件中的阈值为 任务1 获取到的阈值，并将内核的地址换为 任务3 获得的内核地址， 运行指令如下：

    $ gcc -march=native  MeltdownExperiment.c -o  MeltdownExperiment
	$ ./MeltdownExperiment

**任务6需提交内容** 观察执行结果，看能否成功地访问到假设内核空间中的秘密数据。

### 7. 两种方法提升赢得竞态条件

乱序后能跑多少后续的代码取决于权限检查的速度，权限检查越慢，乱序后可以跑的代码越多，这是一个竞态条件，本次的两个任务就是利用这个竞态条件从内核中获取秘密数据。

### 7.1 观察Cache中是否加载到kernel_data的值

在任务6中，我们将数组 [7*4096+DELTA] 放入 CPU 缓存中，使用 FLUSH+RELOAD 技术，我们通过遍历 i= 0, . . .，255 ，检查数组 [i*4096+DELTA] 的访问时间。如果我们发现只有 array[k*4096+DELTA] 在缓存中，我们可以推断 k 的值等于 7 。

本次任务将修改代码访问 array[kernel_data*4096+DELTA] ，根据任务 6 ，修改 MeltdownExperiment.c 代码，编译运行后，观察执行结果。

<center><img src="../assets/7-1.png" width = 600></center>

修改完 MeltdownExperiment.c 保存后，继续执行下面的命令：

    $ gcc -march=native  MeltdownExperiment.c -o  MeltdownExperiment
	$ ./ MeltdownExperiment

发现应该基本不会成功的获取到内核数据的值。原因是在 CPU 乱序执行到 array[kernel_data * 4096 + DELTA] += 1 的时候，需要加载数据到寄存器里面；同步地会执行对 kernel_data 访问的 check 。如果数据加载的执行慢于 check 的话，一旦 check 完成，发现没有权限访问，所以直接丢出 exception ，乱序执行就此中断，此过程中并未完成 array[kernel_data * 4096 + DELTA] += 1 语句的执行。

**任务7.1需提交内容** 观察执行结果，看能否成功地访问到内核空间中的秘密数据。（大概率不成功，所以不成功的同学不要焦虑，是正常情况）

### 7.2 通过加载内核缓存秘密数据实施攻击

本次任务是把内核态的秘密数据加载到 CPU 的 Cache 中，并尝试是否能在用户空间访问该秘密数据。

需要在任务 7.1 的基础上添加如下代码， 代码加在 flushSideChannel() 之后。

<center><img src="../assets/2-9 task7 内核加载的代码.png" width = 600></center>

**任务7.2需提交内容** 观察执行结果，看能否成功地访问到内核空间中的秘密数据。（大概率不成功，所以不成功的同学不要焦虑，是正常情况）

### 7.3 使用汇编代码触发Meltdown攻击

即使CPU缓存了秘密数据，我们在任务7.2中仍然可能无法成功获取到秘密数据。

本任务通过在访问内核内存之前添加几行汇编指令来进行改进。下面是meltdown asm（）中的代码。代码基本上循环400次（见第行）➀); 内部循环，它只需将数字0x141添加到eax寄存器。这段代码基本上做无用的计算，但是这些额外的代码行“给了算法单元一些需要处理的内容，正在推测内存访问”。这是增加成功可能性的一个重要技巧。

<center><img src="../assets/2-10 task7 汇编代码.png" width = 600></center>

**任务7.3需提交内容** 请调用 meltdown_asm（）函数，而不是原来的 meltdown（）函数。描述你的观察。增加和减少循环数，并报告结果。


### 8 优化完成更有效的 Meltdown 攻击

即使在任务7 中进行了优化，我们可能仍然无法每次都获得秘密数据。为了提高准确度，我们可以使用统计技术。就是创造大小为256的积分数组，每个可能的秘密数据对应一个数组元素。然后我们发动多次攻击次。每一次，如果我们的攻击程序说k是秘密（这个结果可能是假的），我们加1到score[k]。在多次执行攻击之后，我们使用得分最高的k值作为我们的目标秘密的最终估计。这将产生一个更可靠的估计。可以将修订后的代码命名为MeltdownAttack.c。

    $ gcc -march=native   MeltdownAttack.c -o  MeltdownAttack
	$ ./MeltdownAttack

得到第一个秘密值 S ，每次对地址进行+1操作。直到成功获取了内核模块中的8个秘密值“SEEDLabs”。


**任务8需提交内容** 需要修改代码获取这8个秘密数据，可以采用循环的方式,截图显示结果。
